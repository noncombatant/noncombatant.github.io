<!doctype html><html lang=en-us><meta charset=utf-8><meta name=viewport content="width=device-width"><meta name=author content="Chris Palmer"><meta name=robots content="noai, noimageai"><title>Prioritizing Memory Safety Migrations</title><link rel=alternate type=application/rss+xml href=/feed/ title=Noncombatant><link rel=icon href=/favicon.svg type=image/svg+xml><link rel=stylesheet href=/style.css><nav><a href=/>Noncombatant</a>
🙂&nbsp;<a href=/about/>About</a>
✍️&nbsp;<a href=/publications/>Other Writing</a>
🎵&nbsp;<a href=https://noncombatant.bandcamp.com/>Bandcamp</a>
💻&nbsp;<a href=https://github.com/noncombatant>GitHub</a>
🐘&nbsp;<a rel=me href=https://wandering.shop/@fugueish>Mastodon</a>
🦋&nbsp;<a href=https://bsky.app/profile/fugueish.bsky.social>Bluesky</a></nav><style>img{border:0}</style><h1>Prioritizing Memory Safety Migrations</h1><p><time>9 April 2021</time><aside><p>Update 11 April: Please also see <a href=/2021/04/11/long-live-sandboxing/>Long Live Sandboxing!</a>. Sandboxing
is not dead, despite what you might have heard.</aside><p>With all the talk of using Rust to reduce memory unsafety bugs, <a href=https://security.googleblog.com/2021/04/rust-in-android-platform.html>such
as Android using Rust in the Android Open Source Project</a>, there’s a lot of
extremely reasonable concern about the high cost of “rewriting it all in Rust”
(or any other safer language), as it’s often phrased. Operating systems, web
browsers, complex online services, and so on can be implemented with tens of
millions of lines of C/C++ code. (<a href=https://www.technologyreview.com/2012/12/03/181350/many-cars-have-a-hundred-million-lines-of-code/>Sometimes
more</a>.) Rewriting all that seems prohibitively expensive, and exacerbates <a href=https://www.usenix.org/conference/enigma2021/presentation/gaynor>what
Alex Gaynor aptly calls grief</a>grunk —  people stay in the denial stage longer when
struck by the enormity of the memory unsafety problem.<p>Thankfully, <a href=https://wiki.mozilla.org/Oxidation>replacing C/C++ with
code in a safer language</a> is not an all-or-nothing task. We can do it
gradually; some parts we might never need to replace. Most safer languages can
link in the same address space as C and/or C++, and call into and be called by
C/C++. You can also normalize data structures such that the safe code handles
arbitrary inputs, and the C/C++ code can focus on a single, simpler grammar. For
example:<figure><svg width="242pt" height="260pt" role="img" aria-label="a directed graph showing internet → { PNG, JPEG, GIF, TIFF, ... } → SkBitmap" viewBox="0 0 242 260" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 256)"><g id="node1" class="node"><title>internet</title><path fill="none" stroke="var(--fg)" d="M42-144s-30 0-30 0c-6 0-12 6-12 12v12c0 6 6 12 12 12h30c6 0 12-6 12-12v-12c0-6-6-12-12-12"/><text text-anchor="middle" x="27" y="-123.8" font-family="Roboto" font-size="9">internet</text></g><g id="node2" class="node"><title>PNG</title><path fill="none" stroke="var(--fg)" d="M132-252s-30 0-30 0c-6 0-12 6-12 12v12c0 6 6 12 12 12h30c6 0 12-6 12-12v-12c0-6-6-12-12-12"/><text text-anchor="middle" x="117" y="-231.8" font-family="Roboto" font-size="9">PNG</text></g><g id="edge1" class="edge"><title>internet->PNG</title><path fill="none" stroke="var(--fg)" d="M42.07-144.38C60.36-168.28 90-207 90-207S90.54-207.56 91.45-208.51"/><path fill="var(--fg)" stroke="var(--fg)" d="M89.06-211.07 98.51-215.84 94.1-206.21 89.06-211.07z"/></g><g id="node3" class="node"><title>JPEG</title><path fill="none" stroke="var(--fg)" d="M132-198s-30 0-30 0c-6 0-12 6-12 12v12c0 6 6 12 12 12h30c6 0 12-6 12-12v-12c0-6-6-12-12-12"/><text text-anchor="middle" x="117" y="-177.8" font-family="Roboto" font-size="9">JPEG</text></g><g id="edge2" class="edge"><title>internet->JPEG</title><path fill="none" stroke="var(--fg)" d="M54.4-142.2C62.83-147.37 72.29-153.18 81.22-158.66"/><path fill="var(--fg)" stroke="var(--fg)" d="M79.57-161.75 89.92-164l-6.69 8.22L79.57-161.75z"/></g><g id="node4" class="node"><title>GIF</title><path fill="none" stroke="var(--fg)" d="M132-144s-30 0-30 0c-6 0-12 6-12 12v12c0 6 6 12 12 12h30c6 0 12-6 12-12v-12c0-6-6-12-12-12"/><text text-anchor="middle" x="117" y="-123.8" font-family="Roboto" font-size="9">GIF</text></g><g id="edge3" class="edge"><title>internet->GIF</title><path fill="none" stroke="var(--fg)" d="M54.4-126c7.99.0 16.91.0 25.42.0"/><path fill="var(--fg)" stroke="var(--fg)" d="M79.92-129.5l10 3.5-10 3.5v-7z"/></g><g id="node5" class="node"><title>TIFF</title><path fill="none" stroke="var(--fg)" d="M132-90s-30 0-30 0c-6 0-12 6-12 12v12c0 6 6 12 12 12h30c6 0 12-6 12-12v-12c0-6-6-12-12-12"/><text text-anchor="middle" x="117" y="-69.8" font-family="Roboto" font-size="9">TIFF</text></g><g id="edge4" class="edge"><title>internet->TIFF</title><path fill="none" stroke="var(--fg)" d="M54.4-109.8c8.43 5.17 17.89 10.98 26.82 16.46"/><path fill="var(--fg)" stroke="var(--fg)" d="M83.23-96.22 89.92-88 79.57-90.25 83.23-96.22z"/></g><g id="node6" class="node"><title>...</title><path fill="none" stroke="var(--fg)" d="M132-36s-30 0-30 0c-6 0-12 6-12 12v12c0 6 6 12 12 12h30c6 0 12-6 12-12v-12c0-6-6-12-12-12"/><text text-anchor="middle" x="117" y="-15.8" font-family="Roboto" font-size="9">...</text></g><g id="edge5" class="edge"><title>internet->...</title><path fill="none" stroke="var(--fg)" d="M42.07-107.62C60.36-83.72 90-45 90-45S90.54-44.44 91.45-43.49"/><path fill="var(--fg)" stroke="var(--fg)" d="M94.1-45.79 98.51-36.16l-9.45-4.77L94.1-45.79z"/></g><g id="node7" class="node"><title>SkBitmap</title><path fill="none" stroke="var(--fg)" d="M222-144s-30 0-30 0c-6 0-12 6-12 12v12c0 6 6 12 12 12h30c6 0 12-6 12-12v-12c0-6-6-12-12-12"/><text text-anchor="middle" x="207" y="-123.8" font-family="Roboto" font-size="9">SkBitmap</text></g><g id="edge6" class="edge"><title>PNG->SkBitmap</title><path fill="none" stroke="var(--fg)" d="M135.49-215.84C140.19-210.96 144-207 144-207s23.72 30.98 41.81 54.63"/><path fill="var(--fg)" stroke="var(--fg)" d="M188.63-154.45 191.93-144.38 183.07-150.19 188.63-154.45z"/></g><g id="edge7" class="edge"><title>JPEG->SkBitmap</title><path fill="none" stroke="var(--fg)" d="M144.4-163.8C152.83-158.63 162.29-152.82 171.22-147.34"/><path fill="var(--fg)" stroke="var(--fg)" d="M173.23-150.22l6.69 8.22-10.35-2.25 3.66-5.97z"/></g><g id="edge8" class="edge"><title>GIF->SkBitmap</title><path fill="none" stroke="var(--fg)" d="M144.4-126C152.39-126 161.31-126 169.82-126"/><path fill="var(--fg)" stroke="var(--fg)" d="M169.92-129.5l10 3.5-10 3.5v-7z"/></g><g id="edge9" class="edge"><title>TIFF->SkBitmap</title><path fill="none" stroke="var(--fg)" d="M144.4-88.2C152.83-93.37 162.29-99.18 171.22-104.66"/><path fill="var(--fg)" stroke="var(--fg)" d="M169.57-107.75 179.92-110l-6.69 8.22-3.66-5.97z"/></g><g id="edge10" class="edge"><title>...->SkBitmap</title><path fill="none" stroke="var(--fg)" d="M135.49-36.16C140.19-41.04 144-45 144-45s23.72-30.98 41.81-54.63"/><path fill="var(--fg)" stroke="var(--fg)" d="M183.07-101.81 191.93-107.62 188.63-97.55 183.07-101.81z"/></g></g></svg><figcaption>You can accept
arbitrary image (e.g.) formats from the internet, use a safer language to
normalize them into Skia’s simple <code>SkBitmap</code> format, and then handle
the bitmaps in Skia in C++. This simplifies the C++ code (reducing its attack
surface), and provides a simple cross-language interface.</figcaption></figure><p>But how do you tell where to start replacing C/C++ with safer code, and where
to stop?<p>Although security is certainly not the only benefit of a safe languagegrunk —  the
Android team’s post starts out stressing correctnessgrunk — my perspective is
security. And from that starting point, we can use what I think is a pretty
clear method to prioritize our efforts.<p>Even if you have, say, 20 million lines of C++ code, not all of it is
directly or indirectly exposed to attackers. You can start hardening the most
exposed code first, and you can rank exposure by how long the path to the code
is. Consider <a href=https://googleprojectzero.blogspot.com/2020/12/an-ios-zero-click-radio-proximity.html>Ian
Beer’s epic radio pyrotechnics</a>, in which he compromised iPhones by sending
them mean-spirited packets by radio. We can model the attack surface exposure
something like this:<figure><svg width="259pt" height="44pt" role="img" aria-label="a directed graph showing attacker → radio chip → kernel" viewBox="0 0 259 44" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 40)"><g id="node1" class="node"><title>attacker</title><path fill="none" stroke="var(--fg)" d="M42-36H12C6-36 0-30 0-24v12C0-6 6 0 12 0h30c6 0 12-6 12-12v-12c0-6-6-12-12-12"/><text text-anchor="middle" x="27" y="-15.8" font-family="Roboto" font-size="9">attacker</text></g><g id="node2" class="node"><title>radio</title><path fill="none" stroke="var(--fg)" d="M134-36s-32 0-32 0c-6 0-12 6-12 12v12c0 6 6 12 12 12h32c6 0 12-6 12-12v-12c0-6-6-12-12-12"/><text text-anchor="middle" x="118" y="-15.8" font-family="Roboto" font-size="9">radio chip</text></g><g id="edge1" class="edge"><title>attacker->radio</title><path fill="none" stroke="var(--fg)" d="M54.22-18c7.95.0 16.84.0 25.37.0"/><path fill="var(--fg)" stroke="var(--fg)" d="M79.73-21.5l10 3.5-10 3.5v-7z"/></g><g id="node3" class="node"><title>kernel</title><path fill="none" stroke="var(--fg)" d="M239-36s-45 0-45 0c-6 0-12 6-12 12v12c0 6 6 12 12 12h45c6 0 12-6 12-12v-12c0-6-6-12-12-12"/><text text-anchor="middle" x="216.5" y="-15.8" font-family="Roboto" font-size="9">device driver</text></g><g id="edge2" class="edge"><title>radio->kernel</title><path fill="none" stroke="var(--fg)" d="M146.14-18C154.07-18 162.95-18 171.64-18"/><path fill="var(--fg)" stroke="var(--fg)" d="M171.69-21.5l10 3.5-10 3.5v-7z"/></g></g></svg><figcaption>An attack pathway from the internet
to the kernel.</figcaption></figure><p>That’s a bit of an oversimplification, but it lets us see that the attacker’s
call graph is not very deepgrunk —  that is, that driver is pretty exposed.<p>Additionally, as the title of Ian’s post points out, the attacker’s cost to
traverse the first few edges is 0. We can model that by assigning ‘weight’ or
‘cost’ to the edges in the graph. The higher the cost, the less likely it is
that the attacker will succeed. Assuming the radio is fairly simple and does
little normalization or filtering before passing what it got to the kernel, we
might draw something like this:<figure><svg width="300pt" height="46pt" role="img" aria-label="a directed graph showing attacker → (0) radio chip → (low or medium) kernel" viewBox="0 0 300 46" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 42)"><g id="node1" class="node"><title>attacker</title><path fill="none" stroke="var(--fg)" d="M42-36H12C6-36 0-30 0-24v12C0-6 6 0 12 0h30c6 0 12-6 12-12v-12c0-6-6-12-12-12"/><text text-anchor="middle" x="27" y="-15.8" font-family="Roboto" font-size="9">attacker</text></g><g id="node2" class="node"><title>radio</title><path fill="none" stroke="var(--fg)" d="M140-36s-32 0-32 0c-6 0-12 6-12 12v12c0 6 6 12 12 12h32c6 0 12-6 12-12v-12c0-6-6-12-12-12"/><text text-anchor="middle" x="124" y="-15.8" font-family="Roboto" font-size="9">radio chip</text></g><g id="edge1" class="edge"><title>attacker->radio</title><path fill="none" stroke="var(--fg)" d="M54.21-18c9.72.0 20.94.0 31.46.0"/><path fill="var(--fg)" stroke="var(--fg)" d="M85.88-21.5l10 3.5-10 3.5v-7z"/><text text-anchor="middle" x="75" y="-20.8" font-family="Roboto" font-size="9">0</text></g><g id="node3" class="node"><title>kernel</title><path fill="none" stroke="var(--fg)" d="M280-36s-45 0-45 0c-6 0-12 6-12 12v12c0 6 6 12 12 12h45c6 0 12-6 12-12v-12c0-6-6-12-12-12"/><text text-anchor="middle" x="257.5" y="-15.8" font-family="Roboto" font-size="9">device driver</text></g><g id="edge2" class="edge"><title>radio->kernel</title><path fill="none" stroke="var(--fg)" d="M152.25-18c17.42.0 40.42.0 60.38.0"/><path fill="var(--fg)" stroke="var(--fg)" d="M212.74-21.5l10 3.5-10 3.5v-7z"/><text text-anchor="middle" x="187.5" y="-30.8" font-family="Roboto" font-size="9">low or</text><text text-anchor="middle" x="187.5" y="-20.8" font-family="Roboto" font-size="9">medium</text></g></g></svg><figcaption>An attack
pathway from the internet to the kernel, with estimated costs for each edge
traversal.</figcaption></figure><p>On a scale from 0 &lt; low &lt; medium &lt; high, we might generously
estimate the cost to exploit the vulnerable driver to be maybe medium. If the
defender is lucky, maybe ASLR is working, or something.<p>Ian explains everything in full detail in his post, but in general we should
not think of C/C++ code as defensible. If an attacker is able to get at C/C++
attack surface, we must assume they can win with an exploit based on memory
unsafety.<p>As an additional example, consider your web server’s or browser’s TLS
implementation. Should we consider it exposed? We can model it something like
this:<figure><svg width="536pt" height="46pt" role="img" aria-label="a directed graph showing attacker → (0, low, or medium) net interface → (passthru) kernel → (passthru) TCP → (low or medium) TLS" viewBox="0 0 536 46" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 42)"><g id="node1" class="node"><title>attacker</title><path fill="none" stroke="var(--fg)" d="M42-36H12C6-36 0-30 0-24v12C0-6 6 0 12 0h30c6 0 12-6 12-12v-12c0-6-6-12-12-12"/><text text-anchor="middle" x="27" y="-15.8" font-family="Roboto" font-size="9">attacker</text></g><g id="node2" class="node"><title>NIC</title><path fill="none" stroke="var(--fg)" d="M184-36s-44 0-44 0c-6 0-12 6-12 12v12c0 6 6 12 12 12h44c6 0 12-6 12-12v-12c0-6-6-12-12-12"/><text text-anchor="middle" x="162" y="-15.8" font-family="Roboto" font-size="9">net interface</text></g><g id="edge1" class="edge"><title>attacker->NIC</title><path fill="none" stroke="var(--fg)" d="M54.28-18c18 0 42.3.0 63.17.0"/><path fill="var(--fg)" stroke="var(--fg)" d="M117.69-21.5l10 3.5-10 3.5v-7z"/><text text-anchor="middle" x="91" y="-30.8" font-family="Roboto" font-size="9">0, low, or</text><text text-anchor="middle" x="91" y="-20.8" font-family="Roboto" font-size="9">medium</text></g><g id="node3" class="node"><title>kernel</title><path fill="none" stroke="var(--fg)" d="M295-36s-45 0-45 0c-6 0-12 6-12 12v12c0 6 6 12 12 12h45c6 0 12-6 12-12v-12c0-6-6-12-12-12"/><text text-anchor="middle" x="272.5" y="-15.8" font-family="Roboto" font-size="9">device driver</text></g><g id="edge2" class="edge"><title>NIC->kernel</title><path fill="none" stroke="var(--fg)" d="M196.14-18C206.05-18 217.07-18 227.56-18"/><path fill="var(--fg)" stroke="var(--fg)" d="M227.81-21.5l10 3.5-10 3.5v-7z"/><text text-anchor="middle" x="217" y="-20.8" font-family="Roboto" font-size="9">0</text></g><g id="node4" class="node"><title>TCP</title><path fill="none" stroke="var(--fg)" d="M391-36s-30 0-30 0c-6 0-12 6-12 12v12c0 6 6 12 12 12h30c6 0 12-6 12-12v-12c0-6-6-12-12-12"/><text text-anchor="middle" x="376" y="-15.8" font-family="Roboto" font-size="9">TCP</text></g><g id="edge3" class="edge"><title>kernel->TCP</title><path fill="none" stroke="var(--fg)" d="M307.02-18c10.22.0 21.5.0 31.88.0"/><path fill="var(--fg)" stroke="var(--fg)" d="M338.91-21.5l10 3.5-10 3.5v-7z"/><text text-anchor="middle" x="328" y="-20.8" font-family="Roboto" font-size="9">0</text></g><g id="node5" class="node"><title>TLS</title><path fill="none" stroke="var(--fg)" d="M516-36s-30 0-30 0c-6 0-12 6-12 12v12c0 6 6 12 12 12h30c6 0 12-6 12-12v-12c0-6-6-12-12-12"/><text text-anchor="middle" x="501" y="-15.8" font-family="Roboto" font-size="9">TLS</text></g><g id="edge4" class="edge"><title>TCP->TLS</title><path fill="none" stroke="var(--fg)" d="M403.09-18c17.69.0 41.31.0 60.81.0"/><path fill="var(--fg)" stroke="var(--fg)" d="M463.95-21.5l10 3.5-10 3.5v-7z"/><text text-anchor="middle" x="438.5" y="-30.8" font-family="Roboto" font-size="9">low or</text><text text-anchor="middle" x="438.5" y="-20.8" font-family="Roboto" font-size="9">medium</text></g></g></svg><figcaption>An attack pathway from the internet to
the application’s TLS implementation.</figcaption></figure><p>In this case, the attacker is interested only in the application’s TLS
implementation, and is just using the kernel as a way to get theregrunk —  they are
not attacking the device driver or the TCP implementation. (Although those are
also exposed attack surfaces, of course.) The kernel typically does not do
anything with the application layer traffic, passing it verbatim to the userland
application. So the kernel is not creating a security boundary in this case.<p>The attacker has a pretty straight shot to your application’s TLS
implementation; the only attack precondition is whether the attacker can send
malicious TLS traffic to the application. Obviously, servers listen to the
internet and process whatever they get; that’s 0 cost. If attacking a client, an
attacker may have to get the target to contact their server or may have to be on
the same network as the target. We might say that is up to medium cost.<p>So, things like device drivers and HTTP, TCP, and TLS implementations are all
fine candidates for (re)implementing in a safer language. They’re unavoidably
exposed.<p>Consider an example where the C/C++ attack surface is not as directly
exposed.<figure><svg width="425pt" height="44pt" role="img" aria-label="a directed graph showing attacker → ... → HTTP → parse CSP → evaluate CSP" viewBox="0 0 425 44" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 40)"><g id="node1" class="node"><title>attacker</title><path fill="none" stroke="var(--fg)" d="M42-36H12C6-36 0-30 0-24v12C0-6 6 0 12 0h30c6 0 12-6 12-12v-12c0-6-6-12-12-12"/><text text-anchor="middle" x="27" y="-15.8" font-family="Roboto" font-size="9">attacker</text></g><g id="node2" class="node"><title>stuff</title><path fill="none" stroke="var(--fg)" d="M132-36s-30 0-30 0c-6 0-12 6-12 12v12c0 6 6 12 12 12h30c6 0 12-6 12-12v-12c0-6-6-12-12-12"/><text text-anchor="middle" x="117" y="-15.8" font-family="Roboto" font-size="9">...</text></g><g id="edge1" class="edge"><title>attacker->stuff</title><path fill="none" stroke="var(--fg)" d="M54.4-18c7.99.0 16.91.0 25.42.0"/><path fill="var(--fg)" stroke="var(--fg)" d="M79.92-21.5l10 3.5-10 3.5v-7z"/></g><g id="node3" class="node"><title>HTTP</title><path fill="none" stroke="var(--fg)" d="M222-36s-30 0-30 0c-6 0-12 6-12 12v12c0 6 6 12 12 12h30c6 0 12-6 12-12v-12c0-6-6-12-12-12"/><text text-anchor="middle" x="207" y="-15.8" font-family="Roboto" font-size="9">HTTP</text></g><g id="edge2" class="edge"><title>stuff->HTTP</title><path fill="none" stroke="var(--fg)" d="M144.4-18C152.39-18 161.31-18 169.82-18"/><path fill="var(--fg)" stroke="var(--fg)" d="M169.92-21.5l10 3.5-10 3.5v-7z"/></g><g id="node4" class="node"><title>parse_CSP</title><path fill="none" stroke="var(--fg)" d="M315-36s-33 0-33 0c-6 0-12 6-12 12v12c0 6 6 12 12 12h33c6 0 12-6 12-12v-12c0-6-6-12-12-12"/><text text-anchor="middle" x="298.5" y="-15.8" font-family="Roboto" font-size="9">parse CSP</text></g><g id="edge3" class="edge"><title>HTTP->parse_CSP</title><path fill="none" stroke="var(--fg)" d="M234.37-18C242.29-18 251.13-18 259.64-18"/><path fill="var(--fg)" stroke="var(--fg)" d="M259.76-21.5l10 3.5-10 3.5v-7z"/></g><g id="node5" class="node"><title>eval_CSP</title><path fill="none" stroke="var(--fg)" d="M405-36s-30 0-30 0c-6 0-12 6-12 12v12c0 6 6 12 12 12h30c6 0 12-6 12-12v-12c0-6-6-12-12-12"/><text text-anchor="middle" x="390" y="-15.8" font-family="Roboto" font-size="9">eval CSP</text></g><g id="edge4" class="edge"><title>parse_CSP->eval_CSP</title><path fill="none" stroke="var(--fg)" d="M327.33-18C335.35-18 344.23-18 352.69-18"/><path fill="var(--fg)" stroke="var(--fg)" d="M352.72-21.5l10 3.5-10 3.5v-7z"/></g></g></svg><figcaption>An attack pathway
from the internet to a client’s CSP evaluator.</figcaption></figure><p>In this example, we have an HTTP client that is going to parse and evaluate a
<a href=https://en.wikipedia.org/wiki/Content_Security_Policy>Content Security
Policy</a> (CSP) header. Each of the network interface, device driver, TCP
implementation, TLS client implementation, HTTP client implementation, and CSP
parser are fairly exposed attack surface. For example, if the attacker wants to
exploit some bug in the CSP parser, they can likely rely on all of the previous
components to pass the header value through verbatim to the CSP parser. Thus,
they probably do not create a security boundary.<p>But if the attacker wants to exploit a likely bug class, mis-evaluation of
CSP policy, they must first get past the CSP parser. Although it is vulnerable
attack surface, it does also provide some security boundary: the policy must be
well-formed according to the grammar the parser accepts. Another bug class is
that the parser’s grammar is not necessarily the same as the grammar in the
spec.<p>Thus, we’d be speaking of logic bugs in the CSP parser and/or evaluator. This
is the kind of code that can be buggy in any language; this is not memory
unsafety that can be resolved at scale with a safer language.<p>These examples suggest that you have to get fairly deep into the call graph
before memory unsafety becomes less of a concern. That’s consistent with <a href=https://alexgaynor.net/2020/may/27/science-on-memory-unsafety-and-security/>the
findings that memory unsafety accounts for anywhere from ⅔ to ¾ of
vulnerabilities</a>. The problem is that bad.<p>Models like those above can be step 1 in a process of repair triage. You
might order a set of constraints when filtering through what code to rewrite,
apply mitigations or testing to, or even get rid of first:<ol><li>Select the most exposed code<li>...of that code, start with the highest-privilege code<li>...of that code, start with the code that has the highest observed bug count</ol><p>Or you might triage differently, depending on your situation:<ol><li>Select the most exposed code<li>...of that code, start with the code that has the highest observed bug count<li>...of that code, start with the highest-privilege code</ol><p>Or even:<ol><li>Select the code that has the highest observed bug count<li>...of that code, start with the most exposed code<li>...of that code, start with the highest-privilege code</ol><p>Which approach is appropriate depends on your system. For example, if you are
working entirely in the kernel, all your code runs at the same level of
privilege so you can’t use that as a filter. Or if you are in userland, but your
application is not making use of process sandboxing, consider exploring that
first before starting a rewrite effort.<p>In any case, we don’t have to “rewrite everything in Rust” to significantly
improve memory safety, and we are not lost in a sea of undifferentiated attack
surface. There are ways we can prioritize in a somewhat systematic waygrunk —  we
don’t have to fix random things ad hoc.<p><i>Thanks to Jacob Hoffman-Andrews, Andrew Dunham, and Dev Akhawe for reading
drafts of this post and suggesting helpful improvements!</i><footer><p><a href=https://noncombatant.org/>noncombatant.org</a> by <a xmlns:cc=http://creativecommons.org/ns# href=mailto:chris@noncombatant.org property="cc:attributionName" rel=cc:attributionurl>Chris Palmer</a> is in the Creative Commons,
under the terms of the <a rel=license href=https://creativecommons.org/licenses/by-nc-sa/4.0/>Attribution-NonCommercial-ShareAlike
4.0 International License</a>.</footer>