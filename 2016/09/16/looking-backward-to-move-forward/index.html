<!doctype html><html lang=en-us><meta charset=utf-8><meta name=viewport content="width=device-width"><meta name=author content="Chris Palmer"><meta name=robots content="noai, noimageai"><title>Looking Backward To Move Forward In Software Engineering</title><link rel=alternate type=application/rss+xml href=/feed/ title=Noncombatant><link rel=icon href=/favicon.svg type=image/svg+xml><link rel=stylesheet href=/style.css><nav>üè°&nbsp;<a href=/>Noncombatant</a>
üôÇ&nbsp;<a href=/about/>About</a>
‚úçÔ∏è&nbsp;<a href=/publications/>Other Writing</a>
üéµ&nbsp;<a href=https://noncombatant.bandcamp.com/>Bandcamp</a></nav><main><article><h1>Looking Backward To Move Forward In Software Engineering</h1><p><time>16 September 2016</time><p><a href=http://ascii.textfiles.com/archives/5054>Jason Scott has a
delightful blog post</a> about a hacker, <a href=https://twitter.com/jbrooksbsi>John Brooks</a>, who released an update to
Apple‚Äôs legacy operating system ProDOS. Without access to source code, Brooks
took the object code of ProDOS 2.0.3 and fixed some of its bugs, added features,
and bundled in some new programs. This is amazing on several levels. I‚Äôll quote
liberally from Scott, but do read the whole enjoyable post:<blockquote><p>The project is understatement itself, simply called Prodos 2.4. It updates
ProDOS, the last version of which, 2.0.3, was released in 1993.<p>[...] compatibility has been repaired for the entire Apple II line, from the
first Apple II through to the Apple IIgs, as well as cases of various versions
of 6502 CPUs [...]. Important utilities related to disk transfer, disk
inspection, and program selection have joined the image. The footprint is
smaller, and it runs faster than its predecessor (a wonder in any case of OS
upgrades).<p>First, the pure unique experience of a <em>23-year-gap between upgrades</em>
means that you can see a rare example of what happens when a computer
environment just sits tight for decades, with many eyes on it and many notes
about how the experience can be improved, followed by someone driven enough to
go through methodically and implement all those requests. [...]<p>Next is that this is an operating system upgrade <em>free of commercial and
marketing constraints and drives</em>. Compared with, say, an iOS upgrade that
trumpets the addition of a search function or blares out a proud announcement
that they broke maps because Google kissed another boy at recess. Or Windows 10,
the 1968 Democratic Convention Riot of Operating Systems, which was designed
from the ground up to be compatible with a variety of mobile/tablet products
that are on the way out, and which were shoved down the throats of current users
with a cajoling, insulting methodology with misleading opt-out routes and
freakier and freakier fake-countdowns.</blockquote><p>(Emphasis in original.)<p>I had a great time playing with BASIC in <a href=https://archive.org/details/ProDOS_2_4>the ProDOS 2.4 emulator on
archive.org</a> last night, and it got me thinking. This ‚Äòprimitive‚Äô computing
environment has some advantages that modern systems sometimes lack.<dl><dt>Immediacy.<dd>Because it‚Äôs small and simple, BASIC starts fast. Some machines of the time
even had BASIC in ROM; some even booted directly into BASIC. Apple BASIC
provides graphics (<code>GR</code> and <code>HGR</code>) as well, enabling
people to immediately get started drawing pictures as well as using text mode.
(Python, in a sense a modern BASIC, has <a href=http://effbot.org/tkinterbook/canvas.htm>similar functionality</a>, which
is awesome.)<dt>Simplicity and constraints.<dd>Like spreadsheets, BASIC presents an extremely simplified ‚Äî¬†some would say
fatally limited ‚Äî¬†model of computation. For example, all variables are global
(!). BASIC has <code>GOTO</code> and <code>GOSUB</code>, but most dialects have
no true function calls or exceptions. And so on. But these limitations are not a
problem if the person using the language doesn‚Äôt need the features ‚Äî¬†and it‚Äôs
possible to write plenty of useful applications without them. <a href=http://gizmodo.com/how-steve-wozniak-wrote-basic-for-the-original-apple-fr-1570573636>Steve
Wozniak intended Apple BASIC to be a game development platform</a>, and <a href=https://en.wikipedia.org/wiki/Business_Basic>BASIC got a lot of attention
in the business world as well</a>.<dt>Learnability.<dd>BASIC‚Äôs simplicity and constraints make it much easier for people to learn.
There‚Äôs simply less to know. We all love C for its compact simplicity, and we
all revile C++ for its complex bloat. And we love how slim our K&amp;Rs are next
to the other tech books on the shelf. But BASIC is so simple that <a href=http://www.calormen.com/jsbasic/reference.html>Joshua Bell‚Äôs Quick
Reference</a> gives people most of what they would need to write programs near
the upper range of what BASIC is capable of.</dl><p>Obviously, I don‚Äôt want to give up the nice modern goodness we have. I like
my hundreds of gigabytes of music, wifi, maps, and the modern web. But I think
it‚Äôs hugely important for all software engineers to at least dabble in
retrocomputing once in a while, so that we can see what we‚Äôve lost and what good
lessons we‚Äôve forgotten over the decades.<p>We have, in fact, lost and forgotten many things. Software is not, in fact,
necessarily getting better over time; I often feel that we are treading water
and only making insignificant changes in the margins. Worse, basic
infrastructure code for the entire Internet is <a href=https://en.wikipedia.org/wiki/Libtiff#Website_hijacking>close to being
unmaintained</a> and is <a href=http://blog.npmjs.org/post/141577284765/kik-left-pad-and-npm>at risk of
exploding randomly</a>. We‚Äôve forgotten that stability, by itself, is a feature.
Simplicity, by itself, is a feature. Knowability, learnability, and hackability
are features. (Hackability: I‚Äôd bet it‚Äôs easier to learn 6502 assembly and patch
a binary than it is to get a truly great result while maintaining code written
in a modern JavaScript front-end framework.)<p>A lot of what we are building now seems to be what engineers and other
technical people want, or what their host corporations want, rather than
directly responding to real people‚Äôs real computing needs. When Bricklin and
Frankston shipped <a href=https://en.wikipedia.org/wiki/VisiCalc>VisiCalc</a>,
it directly responded to people‚Äôs needs. Even though spreadsheets present a very
limited model of computation, they present a model that people can learn and use
and which is sufficient to solve real problems. You really can run a business
from Microsoft Excel, and people do. Meanwhile, Apple iTunes seems to get more
mazelike with each release...<p>At this point, hackers in the audience are getting nervous about all my
cheerleading for non-general-purpose computers. What about <a href="http://papers.ssrn.com/sol3/papers.cfm?abstract_id=847124">generativity</a>,
for which we require fully general models of computing? Obviously we
<em>technical people</em> need that. But general models of computing are not
necessarily what most people need from a machine or software product. And many
or most of the problems people have with computers ‚Äî unexplainable errors,
malware, unnecessary bugs, and more ‚Äî¬†are the direct or indirect result of
giving people hacker machines when what they wanted was a spreadsheet
machine.<p>Presenting limited models of computing is <em>not</em> (necessarily) ‚Äòdumbing
the system down‚Äô. A system whose users perceive it to be dumbed down is one that
is not sufficient for its purpose, and sufficiency is still our minimum bar for
shipping. Rather, by presenting people systems that they can learn and use to
solve problems, we are <em>enhancing the human</em>. Consider that presenting a
bash prompt, although it‚Äôs incredibly powerful, does not actually empower most
people. Instead, it confuses and disheartens ‚Äî¬†disempowers ‚Äî¬†them.<p>We technical people need to change our recipe for building and delivering
software. We should not serve only ourselves; we should make sure we‚Äôre not
doing something just because we can; we should not love complexity for its own
sake. I‚Äôd like to see us follow a recipe more like this:<ol><li>Find out what someone‚Äôs problem is.<li>Produce something that is sufficient to solve that problem.<li>At this point, the solution is likely to be simple, because it is merely
sufficient. Make the most of the glorious limitations:<ul><li>The system is small enough for you to document comprehensively. Maybe you
can even document the internals a bit, so that nerds can tinker with it.<li>Spend time polishing the simple UX. Go through every possible flow, and make
sure they are all necessary, and as smooth as possible.<li>There are fewer bugs, right?<li>It should be fast (to run, download, install, et c.), since it‚Äôs sufficient
(small) instead of general (large). Make sure that‚Äôs that case.</ul><li>Iterate, but only if necessary and in response to people‚Äôs needs. Take your
time, even as long as 23 years.</ol></article></main><footer><p><a href=https://noncombatant.org/>noncombatant.org</a> by <a xmlns:cc=http://creativecommons.org/ns# href=mailto:chris@noncombatant.org property=cc:attributionName rel=cc:attributionurl>Chris Palmer</a> is in the
Creative Commons, under the terms of the <a rel=license href=https://creativecommons.org/licenses/by-nc-sa/4.0/>Attribution-NonCommercial-ShareAlike
4.0 International License</a>.</footer>